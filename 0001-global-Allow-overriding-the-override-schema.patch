From 96c97daca0db1ef56125873a8eebef86bdc8087a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Florian=20M=C3=BCllner?= <fmuellner@gnome.org>
Date: Mon, 4 Jun 2018 13:45:06 -0400
Subject: [PATCH] global: Allow overriding the override schema

---
 src/main.c         | 11 ++++++++++-
 src/shell-global.c | 20 +++++++++++++++++++-
 2 files changed, 29 insertions(+), 2 deletions(-)

diff --git a/src/main.c b/src/main.c
index 857877b0b..9d51ee5d1 100644
--- a/src/main.c
+++ b/src/main.c
@@ -12,60 +12,61 @@
 #include <clutter/clutter.h>
 #include <clutter/x11/clutter-x11.h>
 #include <gdk/gdk.h>
 #include <gdk/gdkx.h>
 #include <gtk/gtk.h>
 #include <glib/gi18n-lib.h>
 #include <girepository.h>
 #include <meta/main.h>
 #include <meta/meta-plugin.h>
 #include <meta/prefs.h>
 #include <atk-bridge.h>
 
 #include "shell-global.h"
 #include "shell-global-private.h"
 #include "shell-perf-log.h"
 #include "st.h"
 
 extern GType gnome_shell_plugin_get_type (void);
 
 #define SHELL_DBUS_SERVICE "org.gnome.Shell"
 #define MAGNIFIER_DBUS_SERVICE "org.gnome.Magnifier"
 
 #define OVERRIDES_SCHEMA "org.gnome.shell.overrides"
 
 #define WM_NAME "GNOME Shell"
 #define GNOME_WM_KEYBINDINGS "Mutter,GNOME Shell"
 
 static gboolean is_gdm_mode = FALSE;
 static char *session_mode = NULL;
 static int caught_signal = 0;
+static char *override_schema = NULL;
 
 #define DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER 1
 #define DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER 4
 
 enum {
   SHELL_DEBUG_BACKTRACE_WARNINGS = 1,
   SHELL_DEBUG_BACKTRACE_SEGFAULTS = 2,
 };
 static int _shell_debug;
 static gboolean _tracked_signals[NSIG] = { 0 };
 
 static void
 shell_dbus_acquire_name (GDBusProxy  *bus,
                          guint32      request_name_flags,
                          guint32     *request_name_result,
                          const gchar *name,
                          gboolean     fatal)
 {
   GError *error = NULL;
   GVariant *request_name_variant;
 
   if (!(request_name_variant = g_dbus_proxy_call_sync (bus,
                                                        "RequestName",
                                                        g_variant_new ("(su)", name, request_name_flags),
                                                        0, /* call flags */
                                                        -1, /* timeout */
                                                        NULL, /* cancellable */
                                                        &error)))
     {
       g_printerr ("failed to acquire %s: %s\n", name, error->message);
@@ -423,110 +424,118 @@ print_version (const gchar    *option_name,
 {
   g_print ("GNOME Shell %s\n", VERSION);
   exit (0);
 }
 
 GOptionEntry gnome_shell_options[] = {
   {
     "version", 0, G_OPTION_FLAG_NO_ARG, G_OPTION_ARG_CALLBACK,
     print_version,
     N_("Print version"),
     NULL
   },
   {
     "gdm-mode", 0, G_OPTION_FLAG_HIDDEN, G_OPTION_ARG_NONE,
     &is_gdm_mode,
     N_("Mode used by GDM for login screen"),
     NULL
   },
   {
     "mode", 0, 0, G_OPTION_ARG_STRING,
     &session_mode,
     N_("Use a specific mode, e.g. “gdm” for login screen"),
     "MODE"
   },
   {
     "list-modes", 0, G_OPTION_FLAG_NO_ARG, G_OPTION_ARG_CALLBACK,
     list_modes,
     N_("List possible modes"),
     NULL
   },
+  {
+    "override-schema", 0, 0, G_OPTION_ARG_STRING,
+    &override_schema,
+    N_("Override the override schema"),
+    "SCHEMA"
+  },
   { NULL }
 };
 
 int
 main (int argc, char **argv)
 {
   GOptionContext *ctx;
   GError *error = NULL;
   int ecode;
 
   bindtextdomain (GETTEXT_PACKAGE, LOCALEDIR);
   bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
   textdomain (GETTEXT_PACKAGE);
 
   session_mode = (char *) g_getenv ("GNOME_SHELL_SESSION_MODE");
 
   ctx = meta_get_option_context ();
   g_option_context_add_main_entries (ctx, gnome_shell_options, GETTEXT_PACKAGE);
   g_option_context_add_group (ctx, g_irepository_get_option_group ());
   if (!g_option_context_parse (ctx, &argc, &argv, &error))
     {
       g_printerr ("%s: %s\n", argv[0], error->message);
       exit (1);
     }
 
   g_option_context_free (ctx);
 
   meta_plugin_manager_set_plugin_type (gnome_shell_plugin_get_type ());
 
   meta_set_wm_name (WM_NAME);
   meta_set_gnome_wm_keybindings (GNOME_WM_KEYBINDINGS);
 
   /* Prevent meta_init() from causing gtk to load the atk-bridge*/
   g_setenv ("NO_AT_BRIDGE", "1", TRUE);
   meta_init ();
   g_unsetenv ("NO_AT_BRIDGE");
 
   /* FIXME: Add gjs API to set this stuff and don't depend on the
    * environment.  These propagate to child processes.
    */
   g_setenv ("GJS_DEBUG_OUTPUT", "stderr", TRUE);
   g_setenv ("GJS_DEBUG_TOPICS", "JS ERROR;JS LOG", TRUE);
 
   shell_init_debug (g_getenv ("SHELL_DEBUG"));
 
   shell_dbus_init (meta_get_replace_current_wm ());
   shell_a11y_init ();
   shell_perf_log_init ();
   shell_introspection_init ();
   shell_fonts_init ();
 
   g_log_set_default_handler (default_log_handler, NULL);
 
   /* Initialize the global object */
   if (session_mode == NULL)
     session_mode = is_gdm_mode ? (char *)"gdm" : (char *)"user";
 
-  _shell_global_init ("session-mode", session_mode, NULL);
+  _shell_global_init ("session-mode", session_mode,
+                      "override-schema", override_schema,
+                      NULL);
 
   shell_prefs_init ();
 
   dump_gjs_stack_on_signal (SIGABRT);
   dump_gjs_stack_on_signal (SIGFPE);
   dump_gjs_stack_on_signal (SIGIOT);
   dump_gjs_stack_on_signal (SIGTRAP);
 
   if ((_shell_debug & SHELL_DEBUG_BACKTRACE_SEGFAULTS))
     {
       dump_gjs_stack_on_signal (SIGBUS);
       dump_gjs_stack_on_signal (SIGSEGV);
     }
 
   ecode = meta_run ();
 
   g_debug ("Doing final cleanup");
   _shell_global_destroy_gjs_context (shell_global_get ());
   g_object_unref (shell_global_get ());
 
   return ecode;
 }
diff --git a/src/shell-global.c b/src/shell-global.c
index c67ac4e4a..961fd3a70 100644
--- a/src/shell-global.c
+++ b/src/shell-global.c
@@ -38,158 +38,167 @@
 /* Memory report bits */
 #ifdef HAVE_MALLINFO
 #include <malloc.h>
 #endif
 
 #if defined __OpenBSD__ || defined __FreeBSD__
 #include <sys/sysctl.h>
 #endif
 
 #include "shell-enum-types.h"
 #include "shell-global-private.h"
 #include "shell-perf-log.h"
 #include "shell-window-tracker.h"
 #include "shell-wm.h"
 #include "st.h"
 
 static ShellGlobal *the_object = NULL;
 
 struct _ShellGlobal {
   GObject parent;
 
   ClutterStage *stage;
   Window stage_xwindow;
 
   MetaDisplay *meta_display;
   GdkDisplay *gdk_display;
   Display *xdisplay;
   MetaScreen *meta_screen;
 
   char *session_mode;
+  char *override_schema;
 
   XserverRegion input_region;
 
   GjsContext *js_context;
   MetaPlugin *plugin;
   ShellWM *wm;
   GSettings *settings;
   const char *datadir;
   char *imagedir;
   char *userdatadir;
   GFile *userdatadir_path;
   GFile *runtime_state_path;
 
   StFocusManager *focus_manager;
 
   guint work_count;
   GSList *leisure_closures;
   guint leisure_function_id;
 
   /* For sound notifications */
   ca_context *sound_context;
 
   gboolean has_modal;
   gboolean frame_timestamps;
   gboolean frame_finish_timestamp;
 };
 
 enum {
   PROP_0,
 
   PROP_SESSION_MODE,
+  PROP_OVERRIDE_SCHEMA,
   PROP_SCREEN,
   PROP_DISPLAY,
   PROP_SCREEN_WIDTH,
   PROP_SCREEN_HEIGHT,
   PROP_STAGE,
   PROP_WINDOW_GROUP,
   PROP_TOP_WINDOW_GROUP,
   PROP_WINDOW_MANAGER,
   PROP_SETTINGS,
   PROP_DATADIR,
   PROP_IMAGEDIR,
   PROP_USERDATADIR,
   PROP_FOCUS_MANAGER,
   PROP_FRAME_TIMESTAMPS,
   PROP_FRAME_FINISH_TIMESTAMP,
 };
 
 /* Signals */
 enum
 {
  NOTIFY_ERROR,
  LAST_SIGNAL
 };
 
 G_DEFINE_TYPE(ShellGlobal, shell_global, G_TYPE_OBJECT);
 
 static guint shell_global_signals [LAST_SIGNAL] = { 0 };
 
 static void
 shell_global_set_property(GObject         *object,
                           guint            prop_id,
                           const GValue    *value,
                           GParamSpec      *pspec)
 {
   ShellGlobal *global = SHELL_GLOBAL (object);
 
   switch (prop_id)
     {
     case PROP_SESSION_MODE:
       g_clear_pointer (&global->session_mode, g_free);
       global->session_mode = g_ascii_strdown (g_value_get_string (value), -1);
       break;
+    case PROP_OVERRIDE_SCHEMA:
+      g_clear_pointer (&global->override_schema, g_free);
+      global->override_schema = g_value_dup_string (value);
+      break;
     case PROP_FRAME_TIMESTAMPS:
       global->frame_timestamps = g_value_get_boolean (value);
       break;
     case PROP_FRAME_FINISH_TIMESTAMP:
       global->frame_finish_timestamp = g_value_get_boolean (value);
       break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
     }
 }
 
 static void
 shell_global_get_property(GObject         *object,
                           guint            prop_id,
                           GValue          *value,
                           GParamSpec      *pspec)
 {
   ShellGlobal *global = SHELL_GLOBAL (object);
 
   switch (prop_id)
     {
     case PROP_SESSION_MODE:
       g_value_set_string (value, shell_global_get_session_mode (global));
       break;
+    case PROP_OVERRIDE_SCHEMA:
+      g_value_set_string (value, global->override_schema);
+      break;
     case PROP_SCREEN:
       g_value_set_object (value, global->meta_screen);
       break;
     case PROP_DISPLAY:
       g_value_set_object (value, global->meta_display);
       break;
     case PROP_SCREEN_WIDTH:
       {
         int width, height;
 
         meta_screen_get_size (global->meta_screen, &width, &height);
         g_value_set_int (value, width);
       }
       break;
     case PROP_SCREEN_HEIGHT:
       {
         int width, height;
 
         meta_screen_get_size (global->meta_screen, &width, &height);
         g_value_set_int (value, height);
       }
       break;
     case PROP_STAGE:
       g_value_set_object (value, global->stage);
       break;
     case PROP_WINDOW_GROUP:
       g_value_set_object (value, meta_get_window_group_for_screen (global->meta_screen));
       break;
     case PROP_TOP_WINDOW_GROUP:
       g_value_set_object (value, meta_get_top_window_group_for_screen (global->meta_screen));
@@ -341,60 +350,67 @@ shell_global_finalize (GObject *object)
   g_free (global->imagedir);
   g_free (global->userdatadir);
 
   G_OBJECT_CLASS(shell_global_parent_class)->finalize (object);
 }
 
 static void
 shell_global_class_init (ShellGlobalClass *klass)
 {
   GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
 
   gobject_class->get_property = shell_global_get_property;
   gobject_class->set_property = shell_global_set_property;
   gobject_class->finalize = shell_global_finalize;
 
   shell_global_signals[NOTIFY_ERROR] =
       g_signal_new ("notify-error",
                     G_TYPE_FROM_CLASS (klass),
                     G_SIGNAL_RUN_LAST,
                     0,
                     NULL, NULL, NULL,
                     G_TYPE_NONE, 2,
                     G_TYPE_STRING,
                     G_TYPE_STRING);
 
   g_object_class_install_property (gobject_class,
                                    PROP_SESSION_MODE,
                                    g_param_spec_string ("session-mode",
                                                         "Session Mode",
                                                         "The session mode to use",
+                                                        NULL,
+                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
+  g_object_class_install_property (gobject_class,
+                                   PROP_OVERRIDE_SCHEMA,
+                                   g_param_spec_string ("override-schema",
+                                                        "Override Schema",
+                                                        "The override schema to use",
                                                         "user",
                                                         G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
   g_object_class_install_property (gobject_class,
                                    PROP_SCREEN,
                                    g_param_spec_object ("screen",
                                                         "Screen",
                                                         "Metacity screen object for the shell",
                                                         META_TYPE_SCREEN,
                                                         G_PARAM_READABLE));
 
   g_object_class_install_property (gobject_class,
                                    PROP_SCREEN_WIDTH,
                                    g_param_spec_int ("screen-width",
                                                      "Screen Width",
                                                      "Screen width, in pixels",
                                                      0, G_MAXINT, 1,
                                                      G_PARAM_READABLE));
 
   g_object_class_install_property (gobject_class,
                                    PROP_SCREEN_HEIGHT,
                                    g_param_spec_int ("screen-height",
                                                      "Screen Height",
                                                      "Screen height, in pixels",
                                                      0, G_MAXINT, 1,
                                                      G_PARAM_READABLE));
   g_object_class_install_property (gobject_class,
                                    PROP_DISPLAY,
                                    g_param_spec_object ("display",
                                                         "Display",
                                                         "Metacity display object for the shell",
@@ -1333,61 +1349,63 @@ shell_global_sync_pointer (ShellGlobal *global)
  * @global: A #ShellGlobal
  *
  * Get the global GSettings instance.
  *
  * Return value: (transfer none): The GSettings object
  */
 GSettings *
 shell_global_get_settings (ShellGlobal *global)
 {
   return global->settings;
 }
 
 /**
  * shell_global_get_overrides_settings:
  * @global: A #ShellGlobal
  *
  * Get the session overrides GSettings instance.
  *
  * Return value: (transfer none): The GSettings object
  */
 GSettings *
 shell_global_get_overrides_settings (ShellGlobal *global)
 {
   static GSettings *settings = NULL;
   const char *schema;
 
   g_return_val_if_fail (SHELL_IS_GLOBAL (global), NULL);
 
   if (!settings)
     {
-      if (strcmp (global->session_mode, "classic") == 0)
+      if (global->override_schema != NULL)
+        schema = global->override_schema;
+      else if (strcmp (global->session_mode, "classic") == 0)
         schema = "org.gnome.shell.extensions.classic-overrides";
       else if (strcmp (global->session_mode, "user") == 0)
         schema = "org.gnome.shell.overrides";
       else
         return NULL;
 
       settings = g_settings_new (schema);
     }
 
   return settings;
 }
 
 /**
  * shell_global_get_current_time:
  * @global: A #ShellGlobal
  *
  * Returns: the current X server time from the current Clutter, Gdk, or X
  * event. If called from outside an event handler, this may return
  * %Clutter.CURRENT_TIME (aka 0), or it may return a slightly
  * out-of-date timestamp.
  */
 guint32
 shell_global_get_current_time (ShellGlobal *global)
 {
   guint32 time;
 
   /* meta_display_get_current_time() will return the correct time
      when handling an X or Gdk event, but will return CurrentTime
      from some Clutter event callbacks.
 
-- 
2.17.1

